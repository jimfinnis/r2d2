package hormone
private

:sigmoid |in,w,c:|
    :"(in w c -- out) sigmoid function with centre and width factor"
    # first subtract the centre from the input
    ?in ?c -
    # multiply the width by 0.1 (an arbitrary factor)
    ?w 0.1 *
    # and divide the input by that
    / !in

    # this does 1-1/(e^x+1) - the actual sigmoid function
    1 1 ?in exp  1 +  / -
;

# get float from hash with default. If default is none, there
# must be a value.
:hget |name,df,h:|
    ?name ?h get dup isnone if
        drop ?df
    then
    dup isnone if
        0 ?name " must not be null value" + assert
    then
;

# get a bool from a hash, using the default if not given
    
:hgetb |name,df,h:|
    ?name ?h get dup isnone if
        drop ?df
    then
;

public

# interval handling - use waitinterval to ensure exact
# timing between ticks, having set the interval with
# setinterval. This will also make sure the decay constant
# is calculated from the hormone half life.
:setinterval |t:| ?t!Interval;
0.0!LastTime
:waitinterval  |:t|
    ?LastTime ?Interval +
    time$now - !t
    ?t 0 > if ?t time$delay then
    time$now !LastTime
;

# calculate geometric decay difference equation constant,
# assuming we've set the interval between ticks
:calcdecay |halflife:|
    2.0 ?Interval neg ?halflife / pow
;

# a hormone has the following parameters:
# * input sigmoid centre and width - used to process the input value
#   to generate a value between 0 and 1
# * release rate - the input value, after sigmoid, is multiplied
#   by this and added to the current level (initially zero)
# * decay rate - the current level is multiplied by this
# * output sigmoid centre and width - the current level is processed
#   through this sigmoid to produce the final output value. Set the width
#   very small to produce a boolean output, and check for <0.5.
# The hormone may not have input and output sigmoids - if hasInSig or
# or hasOutSig are false, the sigmoid is omitted.
# The maximum level of the hormone is assumed to be 1, and this
# is enforced by an exponential function.
#
# The parameters are stored in a closure generated by the following
# function, which also stores the current level.
#
# The system also creates a UDP variable for the hormone, from the
# `name element of the hash. This is automatically updated with
# the output when the hormone updates.

:new |h:insigcent,insigwidth,release,decay,outsigcent,outsigwidth,level,output,hasinsig,hasoutsig,udpname|
    :"(insigcent insigwidth release decay outsigcent outsigwidth -- h) make a hormone"
    `hasInSig             1      ?h hgetb !hasinsig
    `hasOutSig            1      ?h hgetb !hasoutsig
    `inSigCent	          0.5    ?h hget !insigcent
    `inSigWidth	          0.3    ?h hget !insigwidth
    `release  	          0.01   ?h hget !release
    `halflife	          10     ?h hget calcdecay !decay
    `outSigCent	          0.5    ?h hget !outsigcent
    `outSigWidth          0.7    ?h hget !outsigwidth
    
    ?h?`name dup !udpname udp$addvar
    0 ?udpname setglobal
    
    0!level
    0!output
    
    # create the hash and store data in it
    [%
     `update (|in:|
         # process the input through the input sigmoid
         ?hasinsig if
             ?in ?insigwidth ?insigcent sigmoid
         else
             ?in
         then
         # multiply this by the release value
         ?release *
         # multiply this by the capping factor, so as there's more hormone
         # the concentration goes up more slowly (from the Endover code,
         # adapted)
         # The idea is that you never reach max concentration, and the more
         # there is, the less diffuses out of the gland.
         0.95 ?level - *
         # add this to the current level
         ?level +
         # decay the new level and store back (but keep on stack)
         ?decay *
         dup !level
         # process through the output sigmoid and store in output,
         # (duplicating so we also get a return value), and also
         # setting the udp variable.
         ?hasoutsig if
             ?outsigwidth ?outsigcent sigmoid
         then
         dup !output
         dup ?udpname setglobal
     ),
     `get (?output),
     `zero (0 !level)
     ]
;


[%`foo 1] !H
